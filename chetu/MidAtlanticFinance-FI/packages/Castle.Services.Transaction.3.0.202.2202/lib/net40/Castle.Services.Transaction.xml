<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.Services.Transaction</name>
    </assembly>
    <members>
        <member name="T:Castle.Services.Transaction.Activities.Activity">
            <summary>
            	Value-object that encapsulates a transaction and is serializable across
            	app-domains.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Activities.Activity.EnlistDependentTask(System.Threading.Tasks.Task)">
            <summary>
            	Enlist a dependent task in the current activity. These tasks will be awaited
            </summary>
            <param name="task">The task to await from the completion of the top most transaction.</param>
            <exception cref="T:System.InvalidOperationException">If there is no current topmost transaction</exception>
        </member>
        <member name="M:Castle.Services.Transaction.Activities.Activity.Push(Castle.Services.Transaction.ITransaction)">
            <summary>
            	Push a transaction onto the stack of transactions.
            </summary>
            <param name = "transaction"></param>
        </member>
        <member name="M:Castle.Services.Transaction.Activities.Activity.Pop">
            <summary>
            	Return the top-most transaction from the stack of transactions.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.Services.Transaction.IDirectoryAdapter">
            <summary>
            	Directory helper. Use this instead of Directory in order to gain
            	transparent interop with transactions (when you want them, as marked by the [Transaction] attribute).
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.Create(System.String)">
            <summary>
            	Creates a directory at the path given.
            	Contrary to the Win32 API, doesn't throw if the directory already
            	exists, but instead returns true. The 'safe' value to get returned 
            	for be interopable with other path/dirutil implementations would
            	hence be false (i.e. that the directory didn't already exist).
            </summary>
            <param name = "path">The path to create the directory at.</param>
            <remarks>
            	True if the directory already existed, False otherwise.
            </remarks>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.Exists(System.String)">
            <summary>
            	Checks whether the path exists.
            </summary>
            <param name = "path">Path to check.</param>
            <returns>True if it exists, false otherwise.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.Delete(System.String)">
            <summary>
            	Deletes a folder recursively.
            </summary>
            <param name = "path"></param>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.Delete(System.String,System.Boolean)">
            <summary>
            	Deletes an empty directory. Non-empty directories will cause false
            	to be returned.
            </summary>
            <param name = "path">The path to the folder to delete.</param>
            <param name = "recursively">
            	Whether to delete recursively or not.
            	When recursive, we delete all subfolders and files in the given
            	directory as well. If not recursive sub-directories and files will not
            	be deleted.
            </param>
            <returns>Whether the delete was successful (i.e. the directory existed and was deleted).</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.GetFullPath(System.String)">
            <summary>
            	Gets the full path of the specified directory.
            </summary>
            <param name = "relativePath">The relative path.</param>
            <returns>A string with the full path.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.MapPath(System.String)">
            <summary>
            	Gets the MapPath of the path. 
             
            	This will be relative to the root web directory if we're in a 
            	web site and otherwise to the executing assembly.
            </summary>
            <param name = "path"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IDirectoryAdapter.Move(System.String,System.String)">
            <summary>
            	Moves the directory from the original path to the new path.
            </summary>
            <param name = "originalPath">Path from</param>
            <param name = "newPath">Path to</param>
        </member>
        <member name="T:Castle.Services.Transaction.IFileAdapter">
            <summary>
             File helper wrapper interface.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.Create(System.String)">
            <summary>
             Create a new file transactionally.
            </summary>
            <param name="filePath">The path, where to create the file.</param>
            <returns>A handle pointing to the file.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.Exists(System.String)">
            <summary>
             Returns whether the specified file exists or not.
            </summary>
            <param name="filePath">The file path.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.ReadAllText(System.String)">
            <summary>
            Reads all text from a file as part of a transaction
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.WriteAllText(System.String,System.String)">
            <summary>
            Writes text to a file as part of a transaction.
            If the file already contains data, first truncates the file
            and then writes all contents in the string to the file.
            </summary>
            <param name="path">Path to write to</param>
            <param name="contents">Contents of the file after writing to it.</param>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.Delete(System.String)">
            <summary>
            Deletes a file as part of a transaction
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.Open(System.String,System.IO.FileMode)">
            <summary>
            Opens a file with RW access.
            </summary>
            <param name="filePath"></param>
            <param name="mode">The file mode, which specifies </param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.WriteStream(System.String,System.IO.Stream)">
            <summary>
            Writes an input stream to the file path.
            </summary>
            <param name="toFilePath">The path to write to.</param>
            <param name="fromStream">The stream to read from.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.ReadAllText(System.String,System.Text.Encoding)">
            <summary>
             Reads all text in a file and returns the string of it.
            </summary>
            <param name="path"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.Move(System.String,System.String)">
            <summary>
             Moves a file from one path to another.
             
             These should all be equivalent:
             <code>
             Move("b/a.txt", "c/a.txt")
             Move("b/a.txt", "c") // given c either is a directory or doesn't exist, otherwise it overwrites the file c
             Move("b/a.txt", "c/") // c must be a directory and might or might not exist. If it doesn't exist it will be created.
             </code>
            </summary>
            <param name="originalFilePath">
             The original file path. It can't be null nor can it point to a directory.
             </param>
             ///<param name="newFilePath">The new location of the file.</param>
        </member>
        <member name="M:Castle.Services.Transaction.IFileAdapter.ReadAllLines(System.String)">
            <summary>
            Read all lines in the given path.
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="T:Castle.Services.Transaction.IMapPath">
            <summary>
            	Small interface for the map path functionality.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IMapPath.MapPath(System.String)">
            <summary>
            	Gets the absolute path given a string formatted
            	as a map path, for example:
            	"~/plugins" or "plugins/integrated" or "C:\a\b\c.txt" or "\\?\C:\a\b"
            	would all be valid map paths.
            </summary>
            <param name = "path"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IRetryPolicy.Retry(System.Exception)">
            <summary>
            </summary>
            <param name = "thrownException"></param>
            <returns>whether another retry should be made</returns>
        </member>
        <member name="P:Castle.Services.Transaction.IRetryPolicy.Failures">
            <summary>
            	Gets the number of times the retry method has been called
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Activities.CallContextActivityManager">
            <summary>
            	The call-context activity manager saves the stack of transactions
            	on the call-stack-context. This is the recommended manager and the default,
            	also.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.IActivityManager">
            <summary>
            	Abstracts approaches to keep transaction activities
            	that may differ based on the environments.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IActivityManager.GetCurrentActivity">
            <summary>
            	Gets the current activity.
            </summary>
            <value>The current activity.</value>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.ContractArgumentValidatorAttribute">
            <summary>
            	Enables factoring legacy if-then-throw into separate methods for reuse and full control over
            	thrown exception and arguments
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.ContractAbbreviatorAttribute">
            <summary>
            	Enables writing abbreviations for contracts that get copied to other methods
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.ContractOptionAttribute">
            <summary>
            	Allows setting contract and tool options at assembly, type, or method granularity.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.ICreatedTransaction">
            <summary>
            	An interface denoting the data structure which
            	carries data about a created transaction.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.ICreatedTransaction.GetForkScope">
            <summary>
            	<para>Call this method from your implementor of the fork-join pattern
            		for the transaction created, in order to correctly notify the transaction manager of
            		the activity going on.</para>
            	<para>
            		The returned disposable instance needs to be thread-safe.
            	</para>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.Services.Transaction.ICreatedTransaction.Transaction">
            <summary>
            	Gets the currently active transaction.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ICreatedTransaction.ShouldFork">
            <summary>
            	Gets whether the transaction manager from which this instance
            	was created allows the potential fork-operation.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.DefaultTransactionOptions">
            <summary>
            	Sample implementation of ITransactionOptions. Use this if you are using <see cref="T:Castle.Services.Transaction.ITransactionManager"/> directly.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.IsolationLevel">
            <summary>
            	Gets the transaction isolation level.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.Mode">
            <summary>
            	Gets the transaction mode.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.DependentOption">
            <summary>
            	<para>Gets the dependent clone option, i.e. the option that
            	specifies what to do with the child/dependent transaction
            	if the parent transaction completes before. The default is
            	BlockCommitUntilComplete and unless you know what you are doing, this is
            	a recommended setting.</para>
            	<para>
            	If you are COMPLETELY SURE you want the main, non-forked transaction
            	to complete without caring for its forked transactions (i.e. racing to complete
            	with them an introducing the random execution patterns this brings), set this
            	property to the non-default RollbackIfNotComplete. This will throw
            	TransactionAbortedExceptions on all forked transactions, which will be silently dropped. 
            </para>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.Fork">
            <summary>
            	Gets whether the current transaction's method should forked off. You might get deadlocks
            	if you have only set one thread on the thread pool.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.Timeout">
            <summary>
            	Gets the Timeout for this managed transaction. Beware that the timeout 
            	for the transaction option is not the same as your database has specified.
            	Often it's a good idea to let your database handle the transactions
            	timing out and leaving this option to its max value. Your mileage may vary though.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.AsyncCommit">
            <summary>
            	Version 3.1: Gets whether the commit should be done asynchronously. Default is false. If you have done a lot of work
            	in the transaction, an asynchronous commit might be preferrable.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.AsyncRollback">
            <summary>
            	Version 3.1: Gets whether a failed transaction should rollback asynchronously after notifying the caller of failure.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionOptions.CustomContext">
            <summary>
            	Gets the custom context dictionary. Implementors of the interface can choose to perform
            	custom logic based on the items in this dictionary. For example, if your infrastructure
            	is capable of handling Database ReadOnly Transactions, tell the infrastructure
            	that through this context-property.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.DefaultTransactionOptions.Equals(Castle.Services.Transaction.ITransactionOptions)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            	true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name = "other">An object to compare with this object.</param>
        </member>
        <member name="M:Castle.Services.Transaction.DefaultTransactionOptions.Equals(Castle.Services.Transaction.DefaultTransactionOptions)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            	true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name = "other">An object to compare with this object.</param>
        </member>
        <member name="M:Castle.Services.Transaction.DefaultTransactionOptions.Equals(System.Object)">
            <summary>
            	Determines whether the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />.
            </summary>
            <returns>
            	true if the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />; otherwise, false.
            </returns>
            <param name = "obj">The <see cref = "T:System.Object" /> to compare with the current <see cref = "T:System.Object" />. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Castle.Services.Transaction.DefaultTransactionOptions.GetHashCode">
            <summary>
            	Serves as a hash function for a particular type.
            </summary>
            <returns>
            	A hash code for the current <see cref = "T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.EnumerableExtensions">
            <summary>
            Helper class with items originally from reactive extensions.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.EnumerableExtensions.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Perform an action as the sequence is enumerated. Is NOT eager, so you must call
            an eager operator to start the side-effects.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.IDependentAware">
            <summary>
            An interface specifying whether the <see cref="T:Castle.Services.Transaction.ITransaction"/> implementation
            knows about its dependents. If the transaction class does not implement this interface
            then dependent transcations that fail will not be awaited on the main thread, but instead
            on the finalizer thread (not good!).
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.IDependentAware.RegisterDependent(System.Threading.Tasks.Task)">
            <summary>
            Registers a dependent task to wait for after Complete or Rollback has been called.
            </summary>
            <param name="task">The task to await.</param>
        </member>
        <member name="T:Castle.Services.Transaction.TransactionMode">
            <summary>Obsolete. Remove usages. This attribute does nothing anymore.</summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionMode.Unspecified">
            <summary>use "Requires" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionMode.NotSupported">
            <summary>use "Supress" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionMode.Requires">
            <summary>use "Requires" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionMode.RequiresNew">
            <summary>use "RequiresNew" on TransactionScopeOption instead.</summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionMode.Supported">
            <summary>use "Requires" on TransactionScopeOption instead.</summary>
        </member>
        <member name="T:Castle.Services.Transaction.IsolationMode">
            <summary>Obsolete. Remove usages. Use <see cref="T:System.Transactions.IsolationLevel"/> instead.</summary>
        </member>
        <member name="T:Castle.Services.Transaction.ISynchronization">
             <summary>Obsolete. Remove usages. Use code like this instead:
             <code>using (var tx = _Tm.CreateTransaction(new DefaultTransactionOptions()).Value.Transaction)
            {
            	tx.Inner.EnlistVolatile(resource, EnlistmentOptions.EnlistDuringPrepareRequired);
            	tx.Complete();
            }</code>
             or alternatively resolve/reference in instance of <see cref="T:Castle.Services.Transaction.ITransactionManager"/> and use 
             <code>(:m).CurrentTransaction.Value.Inner.EnlistResource( <see cref="T:System.Transactions.ISinglePhaseNotification"/> synchronization )</code> 
             instead.
             </summary>
        </member>
        <member name="M:Castle.Services.Transaction.ISynchronization.BeforeCompletion">
            <summary>Use <see cref="T:System.Transactions.ISinglePhaseNotification"/> instead.</summary>
        </member>
        <member name="M:Castle.Services.Transaction.ISynchronization.AfterCompletion">
            <summary>Use <see cref="T:System.Transactions.ISinglePhaseNotification"/> instead.</summary>
        </member>
        <member name="T:Castle.Services.Transaction.CommitResourceException">
            <summary>
            These exceptions won't be thrown anymore. If you are using exceptions to validate your entities you should catch TransactionAbortedException instead of this.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.TransactionException">
            <summary>
            	Exception thrown when the transaction services code has problems.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionException.#ctor">
            <summary>
            	base c'tor
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionException.#ctor(System.String)">
            <summary>
            	c'tor with message
            </summary>
            <param name = "message"></param>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionException.#ctor(System.String,System.Uri)">
            <summary>
            	c'tor with message and a uri (new Uri(...)).
            </summary>
            <param name = "message"></param>
            <param name = "helpLink">A link relating to the exception/offering guidance.</param>
        </member>
        <member name="T:Castle.Services.Transaction.TransactionalConflictException">
            <summary>
            Thrown if a non-transacted file API and a transacted file API try and operate on the same inode/file.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.FileTransaction">
            <summary>
            	Represents a transaction on transactional kernels
            	like the Vista kernel or Server 2008 kernel and newer.
            </summary>
            <remarks>
            	Good information for dealing with the peculiarities of the runtime:
            	http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.safehandle.aspx
            </remarks>
        </member>
        <member name="T:Castle.Services.Transaction.ITransaction">
            <summary>
            	<para>
            		Denotes a castle transaction. This is the main point of interaction between your code and
            		the transactional behaviour of it. Use the transaction manager <see cref="T:Castle.Services.Transaction.ITransactionManager"/> to
            		rollback from within a transactional method.
            	</para><para>
            	       	Implementors of this class should do their best to provide a stable implementation
            	       	where Dispose, Rollback and Complete can be called idempotently. The get-property accessors must
            	       	not change state when gotten.</para>
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.ITransaction.Dispose">
            <summary>
            	Dispose the resource/the transaction. It's important that you call this method
            	when you are using the transaction together with the transaction manager, but 
            	otherwise as well if you want deterministic disposal.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.ITransaction.Rollback">
            <summary>
            	Rolls the transaction back. This method is automatically called on (managed) dispose.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.ITransaction.Complete">
            <summary>
            	Completes the transaction. This method can only be called if the 
            	transaction is in the active state, i.e. begin has been called.
            </summary>
            <exception cref="T:System.Transactions.TransactionInDoubtException">
            	The exception that is thrown when an operation 
            	is attempted on a transaction that is in doubt, 
            	or an attempt is made to commit the transaction 
            	and the transaction becomes InDoubt. 
            </exception>
            <exception cref="T:System.Transactions.TransactionAbortedException">
            	The exception that is thrown when an operation is attempted on a transaction 
            	that has already been rolled back, or an attempt is made to commit 
            	the transaction and the transaction aborts.
            </exception>
            <exception cref="T:Castle.Services.Transaction.TransactionException">An unknown problem occurred. 
            	For example the connection to the database was lost.</exception>
            <exception cref="T:System.AggregateException">
            	One or more dependent transactions failed when using the Fork=true option!
            </exception>
            <remarks>
            	It's up for grabs (i.e. github pull request) to correctly handle state on the two exceptions that may be thrown
            	and to implement sane retry logic for them. All I can guess is that this shouldn't happen
            	unless you run distributed transactions.
            </remarks>
        </member>
        <member name="P:Castle.Services.Transaction.ITransaction.State">
            <summary>
            	Gets the tranaction state. Castle.Service.Transaction contains a number
            	of states which will allow you to reasin about the state.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransaction.CreationOptions">
            <summary>
            	Gets the options used to create this transaction.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransaction.Inner">
            <summary>
            	<para>Gets the inner <see cref="T:System.Transactions.Transaction"/>,
            		which is the foundation upon which Castle.Transactions builds.
            		It can be either a <see cref="T:System.Transactions.CommittableTransaction"/> or a 
            		<see cref="T:System.Transactions.DependentTransaction"/> or a 
            		<see cref="T:System.Transactions.SubordinateTransaction"/>. A dependent transaction
            		can be used to handle concurrency in a nice way.</para>
            
            	<para>This property is null if the transaction's supervising coordinator (i.e.
            		either MS DTC [multiple resources/2PC] or KTM [kernel/2PC] or LTM on Windows)
            		is not based on LTM -- this is true (and hence the property null) for Kernel Transactions, i.e. registry
            		and file transactions that were started before other DTC/LTM-transacted resources.</para>
            </summary>
            <remarks>
            	TODO: Change this property after construction if a new LTM/DTC transaction is created from the same transaction manager.
            </remarks>
        </member>
        <member name="P:Castle.Services.Transaction.ITransaction.KernelTransactionHandle">
            <summary>
            	If the created transaction is a file transaction, there should be a
            	transacted-file-transaction handle available.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransaction.LocalIdentifier">
            <summary>
            	Gets a local identifier unique to the underlying transaction. Contrary to the 
            	underlying System.Transactions.Transaction.TransactionInformation.LocalIdentifier
            	property, this identifier is unique also across committable/dependent transactions
            	whereas the former isn't. Hence, this identifier is well suited to implement
            	per-transaction resolve semantics where even a dependent transaction requires a new 'context'
            	of resolve.
            </summary>
            <remarks>
            As opposed to the local identifier on System.Transactions.Transaction.Current.LocalIdentifier
            this getter does not have side-effects and will return a value despite the inner transaction
            being disposed.
            </remarks>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.Castle#Services#Transaction#IDirectoryAdapter#Create(System.String)">
            <summary>
            	Creates a directory at the path given.
            </summary>
            <param name = "path">The path to create the directory at.</param>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.Castle#Services#Transaction#IDirectoryAdapter#Delete(System.String)">
            <summary>
            	Deletes a folder recursively.
            </summary>
            <param name = "path">The directory path to start deleting at!</param>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.Castle#Services#Transaction#IDirectoryAdapter#Exists(System.String)">
            <summary>
            	Checks whether the path exists.
            </summary>
            <param name = "path">Path to check.</param>
            <returns>True if it exists, false otherwise.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.Castle#Services#Transaction#IDirectoryAdapter#Delete(System.String,System.Boolean)">
            <summary>
            	Deletes an empty directory
            </summary>
            <param name = "path">The path to the folder to delete.</param>
            <param name = "recursively">
            	Whether to delete recursively or not.
            	When recursive, we delete all subfolders and files in the given
            	directory as well.
            </param>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.Dispose">
            <summary>
            	Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            	Creates a file handle with the current ongoing transaction.
            </summary>
            <param name = "path">The path of the file.</param>
            <param name = "mode">The file mode, i.e. what is going to be done if it exists etc.</param>
            <param name = "access">The access rights this handle has.</param>
            <param name = "share">What other handles may be opened; sharing settings.</param>
            <returns>A safe file handle. Not null, but may be invalid.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.TranslateFileMode(System.IO.FileMode)">
            <summary>
            	Managed -> Native mapping
            </summary>
            <param name = "mode"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.TranslateFileAccess(System.IO.FileAccess)">
            <summary>
            	Managed -> Native mapping
            </summary>
            <param name = "access"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.FileTransaction.TranslateFileShare(System.IO.FileShare)">
            <summary>
            	Direct Managed -> Native mapping
            </summary>
            <param name = "share"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.Services.Transaction.FileTransaction.Name">
            <summary>
            	Gets the name of the transaction.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.IKernelTransaction.GetHandle(Castle.Services.Transaction.IO.SafeKernelTransactionHandle@)">
            <summary>
            	Gets a safe transaction handle. If we instead use IntPtr we 
            	might not release the transaction handle properly.
            </summary>
            <param name = "handle"></param>
        </member>
        <member name="T:Castle.Services.Transaction.IO.Directory">
            <summary>
            	Utility class for directories.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.IO.DirectoryAdapter">
            <summary>
            	Adapter which wraps the functionality in <see cref="T:Castle.Services.Transaction.IO.File"/>
            	together with native kernel transactions.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.IO.TransactionAdapterBase">
            <summary>
            	Adapter base class for the file and directory adapters.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.TransactionAdapterBase.TransactionManager">
            <summary>
            	Gets the transaction manager, if there is one, or sets it.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.TransactionAdapterBase.UseTransactions">
            <summary>
            	Gets/sets whether to use transactions.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.DirectoryAdapter.#ctor(Castle.Services.Transaction.IMapPath,System.Boolean,System.String)">
            <summary>
            	Create a new DirectoryAdapter instance. C'tor.
            </summary>
            <param name = "pathFinder">The MapPath implementation.</param>
            <param name = "constrainToSpecifiedDir">Whether to ChJail the DirectoryAdapter.</param>
            <param name = "specifiedDir">The directory to constrain the adapter to.</param>
        </member>
        <member name="T:Castle.Services.Transaction.IO.File">
            <summary>
            	Utility class for file operations.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.IO.FileAdapter">
            <summary>
            	Adapter class for the file transactions
            	which implement the same interface.
            
            	This adapter chooses intelligently whether there's an ambient
            	transaction, and if there is, joins it.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.FileAdapter.#ctor">
            <summary>
            	c'tor
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.FileAdapter.#ctor(System.Boolean,System.String)">
            <summary>
            	c'tor
            </summary>
            <param name = "constrainToSpecifiedDir"></param>
            <param name = "specifiedDir"></param>
        </member>
        <member name="M:Castle.Services.Transaction.IO.FileAdapter.Create(System.String)">
            <summary>
            	Creates a new file from the given path for ReadWrite,
            	different depending on whether we're in a transaction or not.
            </summary>
            <param name = "path">Path to create file at.</param>
            <returns>A filestream for the path.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IO.FileAdapter.Exists(System.String)">
            <summary>
            	Returns whether the specified file exists or not.
            </summary>
            <param name = "filePath">The file path.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Services.Transaction.IO.MapPathImpl">
            <summary>
            	An implementation of the MapPath which seems to be working well with
            	both testfixtures and online. Consumed by <see cref="T:Castle.Services.Transaction.IDirectoryAdapter"/>
            	(or any other object wanting the functionality).
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.MapPathImpl.#ctor">
            <summary>
            	Default c'tor.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.MapPathImpl.#ctor(System.Func{System.String,System.String})">
            <summary>
            	Function may be null.
            </summary>
            <param name = "function"></param>
        </member>
        <member name="M:Castle.Services.Transaction.IO.MapPathImpl.MapPath(System.String)">
            <summary>
            	Gets the absolute path given a string formatted
            	as a map path, for example:
            	"~/plugins" or "plugins/integrated" or "C:\a\b\c.txt" or "\\?\C:\a\b"
            	would all be valid map paths.
            </summary>
            <param name = "path"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Services.Transaction.IO.Path">
            <summary>
            	Utility class meant to replace the <see cref="T:System.IO.Path"/> class completely. This class handles these types of paths:
            	<list>
            		<item>UNC network paths: \\server\folder</item>
            		<item>UNC-specified network paths: \\?\UNC\server\folder</item>
            		<item>IPv4 network paths: \\192.168.3.22\folder</item>
            		<item>Rooted paths: /dev/cdrom0</item>
            		<item>Rooted paths: C:\folder</item>
            		<item>UNC-rooted paths: \\?\C:\folder\file</item>
            		<item>Fully expanded IPv6 paths</item>
            	</list>
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.IsRooted(System.String)">
            <summary>
            	Returns whether the path is rooted. An empty string isn't.
            </summary>
            <param name="path">Gets whether the path is rooted or relative.</param>
            <returns>Whether the path is rooted or not.</returns>
            <exception cref="T:System.ArgumentNullException">If the passed argument is null.</exception>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.GetPathRoot(System.String)">
            <summary>
            	Gets the path root, i.e. e.g. \\?\C:\ if the passed argument is \\?\C:\a\b\c.abc.
            </summary>
            <param name = "path">The path to get the root for.</param>
            <returns>The string denoting the root.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.GetPathWithoutRoot(System.String)">
            <summary>
            	Gets a path without root.
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.NormDirSepChars(System.String)">
            <summary>
            	Normalize all the directory separation chars.
            	Also removes empty space in beginning and end of string.
            </summary>
            <param name="pathWithAlternatingChars"></param>
            <returns>The directory string path with all occurrances of the alternating chars
            	replaced for that specified in <see cref="F:System.IO.Path.DirectorySeparatorChar"/></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.GetPathInfo(System.String)">
            <summary>
            	Gets path info (drive and non root path)
            </summary>
            <param name="path">The path to get the info from.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.GetFullPath(System.String)">
            <summary>
            	Gets the full path for a given path.
            </summary>
            <param name="path"></param>
            <returns>The full path string</returns>
            <exception cref="T:System.ArgumentNullException">if path is null</exception>
        </member>
        <member name="M:Castle.Services.Transaction.IO.Path.GetPathWithoutLastBit(System.String)">
            <summary>
            	Removes the last directory/file off the path.
            
            	For a path "/a/b/c" would return "/a/b"
            	or for "\\?\C:\folderA\folder\B\C\d.txt" would return "\\?\C:\folderA\folder\B\C"
            </summary>
            <param name = "path">The path string to modify</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.IO.PathEx.Combine(System.String,System.String)">
            <summary>
            	Combines an input path and a path together
            	using System.IO.Path.Combine and returns the result.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.IO.PathInfo">
            <summary>
            	Path data holder.
            	Invariant: no fields nor properties are null after c'tor.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.PathInfo.IsParentOf(Castle.Services.Transaction.IO.PathInfo)">
            <summary>
            	Returns whether the current PathInfo is a valid parent of the child path info
            	passed as argument.
            </summary>
            <param name="child">The path info to verify</param>
            <returns>Whether it is true that the current path info is a parent of child.</returns>
            <exception cref="T:System.NotSupportedException">If this instance of path info and child aren't rooted.</exception>
        </member>
        <member name="M:Castle.Services.Transaction.IO.PathInfo.RemoveParameterFromRoot(Castle.Services.Transaction.IO.PathInfo)">
            <summary>
            	Removes the path info passes as a parameter from the current root. Only works for two rooted paths with same root.
            	Does NOT cover all edge cases, please verify its intended results yourself.
            	<example>
            	</example>
            </summary>
            <param name = "other"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.Root">
            <summary>
            	Examples of return values:
            	<list>
            		<item>\\?\UNC\C:\</item>
            		<item>\\?\UNC\servername\</item>
            		<item>\\192.168.0.2\</item>
            		<item>C:\</item>
            	</list>
            
            	Definition: Returns part of the string that is in itself uniquely from the currently 
            	executing CLR.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.UNCPrefix">
            <summary>
            	Examples of return values:
            	<list>
            		<item></item>
            	</list>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.UNCLiteral">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.Options">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.Drive">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.DriveLetter">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.Server">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.IPv4">
            <summary>
            	Gets the 0.0.0.0-based IP-address if any.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.IPv6">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.ServerName">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.Device">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.DevicePrefix">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.DeviceName">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.DeviceGuid">
            <summary>
            	Gets the device GUID in the form
            	<code>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</code>
            	i.e. 8-4-4-4-12 hex digits with curly brackets.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.NonRootPath">
            <summary>
            	Gets a the part of the path that starts when the root ends.
            	The root in turn is any UNC-prefix plus device, drive, server or ip-prefix.
            	This string may not start with neither of '\' or '/'.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.RelDrive">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.FolderAndFiles">
            <summary>
            	The only time when this differs from <see cref="P:Castle.Services.Transaction.IO.PathInfo.NonRootPath"/>
            	is when a path like this is used:
            	<code>C:../parent/a.txt</code>, otherwise, for all paths,
            	this property equals <see cref="P:Castle.Services.Transaction.IO.PathInfo.NonRootPath"/>.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.IO.PathInfo.IsRooted">
            <summary>
            	Returns whether <see cref="P:Castle.Services.Transaction.IO.PathInfo.Root"/> is not an empty string.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.ITransactionManager">
            <summary>
            	The transaction manager takes care of the nitty-gritty details of managing the store for transactions and their data.
            	Its main use-case is creating the actual transactions, given the options for the transaction and the 
            	be the place-to-go-to for knowing what transactions are currently ambient on the current call context.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.ITransactionManager.CreateTransaction">
            <summary>
            	Create a new transaction with the default options <see cref="T:Castle.Services.Transaction.DefaultTransactionOptions"/>. The default options
            	will create a new transaction. Only options with Supress = true will NOT create transactions.
            </summary>
            <returns>Maybe a created transaction. If the default options is to supress transactions, the maybe has no value.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.ITransactionManager.CreateTransaction(Castle.Services.Transaction.ITransactionOptions)">
            <summary>
            	Create a new transaction, given the transaction options.
            </summary>
            <remarks>
            	<para>
            		<see cref="M:System.IDisposable.Dispose"/> the transaction, or transactions further ahead in time will not
            		work properly.
            	</para>
            	<para>
            		Also, beware that if you call this method on your own, you are responsible for setting
            		<see cref="P:System.Transactions.Transaction.Current"/> to the result's Inner property
            		and restoring the previous Current property at the end of that transaction.
            	</para>
            	<para>
            		The transaction interceptor (in AutoTx) takes care of this for you. The two projects
            		work very well together.
            	</para>
            </remarks>
            <param name="transactionOptions">Options to use for creating the new transaction.</param>
            <returns>Maybe a transaction, if the options specified it. If the default options is to supress transactions, the maybe has no value.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.ITransactionManager.CreateFileTransaction(Castle.Services.Transaction.ITransactionOptions)">
            <summary>
            	Create a new transaction, given the transaction options.
            </summary>
            <param name = "transactionOptions">options to use for creating the transaction</param>
            <returns>If the default options is to supress transactions, the maybe has no value.</returns>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionManager.CurrentTopTransaction">
            <summary>
            	<para>Gets the current transaction. If the program has a call context
            		located any methods further down the call-stack with methods with TransactionAttribute,
            		this property gets the top most transaction which is the parent of the CurrentTransaction.
            	</para>
            	<para>
            		Be aware that, when you call this property, only reads on pure properties on the transaction are thread-safe
            		and no methods that are not static are thread-safe. This property can be used with good results to get 
            		a transaction which you can use to register top-most resources in, such as rollback-aware NHibernate-session
            		managers which can refresh the session if there's a fault.
            	</para>
            	<para>
            		The value is Maybe.None() if there's no current transaction.
            	</para>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionManager.CurrentTransaction">
            <summary>
            	<para>Gets the current transaction.
            		The value is Maybe.None() if no transaction is on the current call context.</para>
            	<para>
            		If the current method has TransactionScopeOption.Supress specified but is inside a current transaction, then
            		<see cref="P:System.Transactions.Transaction.Current"/> is null, but this property has the actual value of the transaction.</para>
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.ITransactionManager.Count">
            <summary>
            	Gets the number of transactions on the current context
            	(in which calls to this interface is relevant). The default context
            	is the call context, based on the call stack.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Maybe">
            <summary>
            	Static helper class for creating Maybe monads.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Some``1(``0)">
            <summary>
            	Creates a new maybe monad with a value.
            </summary>
            <typeparam name = "TSome">The type of the value to set the monad to contain.</typeparam>
            <param name = "item">The item</param>
            <returns>A non-null maybe instance of the maybe monad.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Do``1(Castle.Services.Transaction.Maybe{``0},System.Func{``0,Castle.Services.Transaction.Maybe{``0}})">
            <summary>
            	Perform an operation f on the maybe, where f might or mightn't return a Maybe.Some{{T}}.
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "f">A function to continue applying to the monad.</param>
            <returns>The same monad</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Do``1(Castle.Services.Transaction.Maybe{``0},System.Func{``0,``0})">
            <summary>
            	Perform
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Do``2(Castle.Services.Transaction.Maybe{``0},System.Func{``0,Castle.Services.Transaction.Maybe{``1}})">
            <summary>
            </summary>
            <typeparam name = "TSome"></typeparam>
            <typeparam name = "TOther"></typeparam>
            <param name = "maybe"></param>
            <param name = "f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Do``2(Castle.Services.Transaction.Maybe{``0},System.Func{``0,``1})">
            <summary>
            </summary>
            <typeparam name = "TSome"></typeparam>
            <typeparam name = "TOther"></typeparam>
            <param name = "maybe"></param>
            <param name = "f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.OrDefault``1(Castle.Services.Transaction.Maybe{``0},``0)">
            <summary>
            	Returns the maybe or the default value passed as a parameter.
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "default"></param>
            <returns>The unwrapped value of the maybe or otherwise the default.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Amb``1(Castle.Services.Transaction.Maybe{``0},System.Func{Castle.Services.Transaction.Maybe{``0}})">
            <summary>
            	The <c>Ambient</c> operator, that selects the second option if the first is unavailable.
            	Because C# doesn't support lazy parameters, it's a func, i.e. a factory method for getting the
            	second option.
            </summary>
            <typeparam name = "TSome">The type of the maybe</typeparam>
            <param name = "firstOption">The first maybe, which is returned if it has a value</param>
            <param name = "secondOption">Evaluation if the first option fails.</param>
            <returns>Maybe TSome.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.OrThrow``1(Castle.Services.Transaction.Maybe{``0},System.Func{System.Exception})">
            <summary>
            	If the maybe doesn't have a value, throws the exception yielded by the func.
            </summary>
            <typeparam name = "TSome"></typeparam>
            <param name = "maybe"></param>
            <param name = "ex"></param>
            <returns>The item in the maybe.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Maybe.Coerce``2(Castle.Services.Transaction.Maybe{``0})">
            <summary>
            	Type-system hack, in leiu of covariant bind (or rather Do in this monad),
            	changes type of the monad from TImpl to TAssignable, where TImpl : TAssignable.
            	The coercion is still statically typed and correct.
            </summary>
            <typeparam name = "TImpl">The type to convert FROM</typeparam>
            <typeparam name = "TAssignable">The type to convert TO</typeparam>
            <param name = "maybe">The object invoked upon</param>
            <returns>A new type of the same kind of monad.</returns>
        </member>
        <member name="T:Castle.Services.Transaction.Maybe`1">
            <summary>
            	An implementation of the maybe monad.
            </summary>
            <typeparam name = "T"></typeparam>
        </member>
        <member name="P:Castle.Services.Transaction.Maybe`1.HasValue">
            <summary>
            	Gets whether the maybe has a value.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.Maybe`1.Value">
            <summary>
            	Gets the value.
            </summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:Castle.Services.Transaction.Maybe`1.HasValue"/> is false.</exception>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.CreateTransaction(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a new transaction object. Passing too long a description will cause problems. This behaviour is indeterminate right now.
            </summary>
            <remarks>
            Don't pass unicode to the description (there's no Wide-version of this function
            in the kernel).
            http://msdn.microsoft.com/en-us/library/aa366011%28VS.85%29.aspx
            </remarks>
            <param name="lpTransactionAttributes">    
            A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle 
            can be inherited by child processes. If this parameter is NULL, the handle cannot be inherited.
            The lpSecurityDescriptor member of the structure specifies a security descriptor for 
            the new event. If lpTransactionAttributes is NULL, the object gets a default 
            security descriptor. The access control lists (ACL) in the default security 
            descriptor for a transaction come from the primary or impersonation token of the creator.
            </param>
            <param name="uow">Reserved. Must be zero (0).</param>
            <param name="createOptions">
            Any optional transaction instructions. 
            Value:		TRANSACTION_DO_NOT_PROMOTE
            Meaning:	The transaction cannot be distributed.
            </param>
            <param name="isolationLevel">Reserved; specify zero (0).</param>
            <param name="isolationFlags">Reserved; specify zero (0).</param>
            <param name="timeout">    
            The time, in milliseconds, when the transaction will be aborted if it has not already 
            reached the prepared state.
            Specify NULL to provide an infinite timeout.
            </param>
            <param name="description">A user-readable description of the transaction.</param>
            <returns>
            If the function succeeds, the return value is a handle to the transaction.
            If the function fails, the return value is INVALID_HANDLE_VALUE.
            </returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.CommitTransaction(Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            Requests that the specified transaction be committed.
            </summary>
            <remarks>You can commit any transaction handle that has been opened 
            or created using the TRANSACTION_COMMIT permission; any application can 
            commit a transaction, not just the creator.
            This function can only be called if the transaction is still active, 
            not prepared, pre-prepared, or rolled back.</remarks>
            <param name="transaction">
            This handle must have been opened with the TRANSACTION_COMMIT access right. 
            For more information, see KTM Security and Access Rights.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.RollbackTransaction(Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            Requests that the specified transaction be rolled back. This function is synchronous.
            </summary>
            <param name="transaction">A handle to the transaction.</param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.DeleteFileTransactedW(System.String,Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            http://msdn.microsoft.com/en-us/library/aa363916(VS.85).aspx
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.FindFirstFileTransactedW(System.String,Castle.Services.Transaction.Internal.NativeMethods.FINDEX_INFO_LEVELS,Castle.Services.Transaction.Internal.NativeMethods.WIN32_FIND_DATA@,Castle.Services.Transaction.Internal.NativeMethods.FINDEX_SEARCH_OPS,System.IntPtr,System.UInt32,Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <param name="lpFileName"></param>
            <param name="fInfoLevelId"></param>
            <param name="lpFindFileData"></param>
            <param name="fSearchOp">The type of filtering to perform that is different from wildcard matching.</param>
            <param name="lpSearchFilter">
            A pointer to the search criteria if the specified fSearchOp needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name="dwAdditionalFlags">
            Specifies additional flags that control the search.
            FIND_FIRST_EX_CASE_SENSITIVE = 0x1
            Means: Searches are case-sensitive.
            </param>
            <param name="hTransaction"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.FindNextFile(Castle.Services.Transaction.IO.SafeFindHandle,Castle.Services.Transaction.Internal.NativeMethods.WIN32_FIND_DATA@)">
            <summary>
            Continues a file search from a previous call to the FindFirstFile or FindFirstFileEx function.
            If there is a transaction bound to the file enumeration handle, then the files that are returned are subject to transaction isolation rules.
            </summary>
            <remarks>http://msdn.microsoft.com/en-us/library/aa364428%28v=VS.85%29.aspx</remarks>
            <param name="hFindFile">The search handle returned by a previous call to the FindFirstFile or FindFirstFileEx function.</param>
            <param name="lpFindFileData">    A pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.
            The structure can be used in subsequent calls to FindNextFile to indicate from which file to continue the search.
            </param>
            <returns>If the function succeeds, the return value is nonzero and the lpFindFileData parameter contains information about the next file or directory found.
            If the function fails, the return value is zero and the contents of lpFindFileData are indeterminate. To get extended error information, call the GetLastError function.
            If the function fails because no more matching files can be found, the GetLastError function returns ERROR_NO_MORE_FILES.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.FindFirstFileTransacted(System.String,System.Boolean,Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            Not extern
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.FindFirstFileTransactedW(System.String,Castle.Services.Transaction.IO.SafeKernelTransactionHandle,Castle.Services.Transaction.Internal.NativeMethods.WIN32_FIND_DATA@)">
            <summary>
            Not extern
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.CreateDirectoryTransactedW(System.String,System.String,System.IntPtr,Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            http://msdn.microsoft.com/en-us/library/aa363857(VS.85).aspx
            Creates a new directory as a transacted operation, with the attributes of a specified 
            template directory. If the underlying file system supports security on files and 
            directories, the function applies a specified security descriptor to the new directory. 
            The new directory retains the other attributes of the specified template directory.
            </summary>
            <param name="lpTemplateDirectory">
            The path of the directory to use as a template 
            when creating the new directory. This parameter can be NULL.
            </param>
            <param name="lpNewDirectory">The path of the directory to be created. </param>
            <param name="lpSecurityAttributes">A pointer to a SECURITY_ATTRIBUTES structure. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new directory.</param>
            <param name="hTransaction">A handle to the transaction. This handle is returned by the CreateTransaction function.</param>
            <returns>True if the call succeeds, otherwise do a GetLastError.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.RemoveDirectoryTransactedW(System.String,Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            http://msdn.microsoft.com/en-us/library/aa365490(VS.85).aspx
            Deletes an existing empty directory as a transacted operation.
            </summary>
            <param name="lpPathName">
            The path of the directory to be removed. 
            The path must specify an empty directory, 
            and the calling process must have delete access to the directory.
            </param>
            <param name="hTransaction">A handle to the transaction. This handle is returned by the CreateTransaction function.</param>
            <returns>True if the call succeeds, otherwise do a GetLastError.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.NativeMethods.GetFullPathNameTransactedW(System.String,System.Int32,System.Text.StringBuilder,System.IntPtr@,Castle.Services.Transaction.IO.SafeKernelTransactionHandle)">
            <summary>
            http://msdn.microsoft.com/en-us/library/aa364966(VS.85).aspx
            Retrieves the full path and file name of the specified file as a transacted operation.
            </summary>
            <remarks>
            GetFullPathNameTransacted merges the name of the current drive and directory 
            with a specified file name to determine the full path and file name of a 
            specified file. It also calculates the address of the file name portion of
            the full path and file name. This function does not verify that the 
            resulting path and file name are valid, or that they see an existing file 
            on the associated volume.
            </remarks>
            <param name="lpFileName">The name of the file. The file must reside on the local computer; 
            otherwise, the function fails and the last error code is set to 
            ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.</param>
            <param name="nBufferLength">The size of the buffer to receive the null-terminated string for the drive and path, in TCHARs. </param>
            <param name="lpBuffer">A pointer to a buffer that receives the null-terminated string for the drive and path.</param>
            <param name="lpFilePart">A pointer to a buffer that receives the address (in lpBuffer) of the final file name component in the path. 
            Specify NULL if you do not need to receive this information.
            If lpBuffer points to a directory and not a file, lpFilePart receives 0 (zero).</param>
            <param name="hTransaction"></param>
            <returns>If the function succeeds, the return value is the length, in TCHARs, of the string copied to lpBuffer, not including the terminating null character.</returns>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.NativeMethods.NativeFileShare">
            <summary>
            The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the following table).
            If this parameter is zero and CreateFileTransacted succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section of this topic.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an open request that has an open handle, because that would result in the following sharing violation: ERROR_SHARING_VIOLATION. For more information, see Creating and Opening Files.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.NativeFileShare.None">
            <summary>
            Disables subsequent open operations on an object to request any type of access to that object.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.NativeFileShare.Read">
            <summary>
            Enables subsequent open operations on an object to request read access.
            Otherwise, other processes cannot open the object if they request read access.
            If this flag is not specified, but the object has been opened for read access, the function fails.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.NativeFileShare.Write">
            <summary>
            Enables subsequent open operations on an object to request write access.
            Otherwise, other processes cannot open the object if they request write access.
            If this flag is not specified, but the object has been opened for write access or has a file mapping with write access, the function fails.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.NativeFileShare.Delete">
            <summary>
            Enables subsequent open operations on an object to request delete access.
            Otherwise, other processes cannot open the object if they request delete access.
            If this flag is not specified, but the object has been opened for delete access, the function fails.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.NativeMethods.MoveFileFlags">
            <summary>
            This enumeration states options for moving a file.
            http://msdn.microsoft.com/en-us/library/aa365241%28VS.85%29.aspx
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.MoveFileFlags.CopyAllowed">
            <summary>
            If the file is to be moved to a different volume, the function simulates the move by using the CopyFile  and DeleteFile  functions.
            This value cannot be used with MOVEFILE_DELAY_UNTIL_REBOOT.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.MoveFileFlags.CreateHardlink">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.MoveFileFlags.DelayUntilReboot">
            <summary>
            The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.
            This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.
            This value cannot be used with MOVEFILE_COPY_ALLOWED.
            The write operation to the registry value as detailed in the Remarks section is what is transacted. The file move is finished when the computer restarts, after the transaction is complete.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.MoveFileFlags.ReplaceExisting">
            <summary>
            If a file named lpNewFileName exists, the function replaces its contents with the contents of the lpExistingFileName file.
            This value cannot be used if lpNewFileName or lpExistingFileName names a directory.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.Internal.NativeMethods.MoveFileFlags.WriteThrough">
            <summary>
            A call to MoveFileTransacted means that the move file operation is complete when the commit operation is completed. This flag is unnecessary; there are no negative affects if this flag is specified, other than an operation slowdown. The function does not return until the file has actually been moved on the disk.
            Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.
            This value has no effect if MOVEFILE_DELAY_UNTIL_REBOOT is set.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.NativeMethods.SECURITY_ATTRIBUTES">
            <summary>
             Attributes for security interop.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.IO.SafeKernelTransactionHandle">
            <summary>
            	A safe file handle on the transaction resource.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.SafeKernelTransactionHandle.#ctor">
            <summary>
            	Default c'tor
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.IO.SafeKernelTransactionHandle.#ctor(System.IntPtr)">
            <summary>
            	c'tor taking a pointer to a transaction.
            </summary>
            <param name = "handle">The transactional handle.</param>
        </member>
        <member name="M:Castle.Services.Transaction.Transaction.Castle#Services#Transaction#ITransaction#Dispose">
            Possible state changes
            
            Default -> Constructed
            Constructed -> Disposed
            Constructed -> Active
            Active -> CommittedOrCompleted (depends on whether we are committable or not)
            Active -> InDoubt
            Active -> Aborted
            Aborted -> Disposed	# an active transaction may be disposed and then dispose must take take of aborting
        </member>
        <member name="T:Castle.Services.Transaction.TransactionAttribute">
            <summary>
            	Specifies a method as transactional. When adding this interface to a method you can use an inversion of control container
            	to intercept method calls to that method and perform the method transactionally. In the 'recommended' implementation,
            	you can use Windsor and the AutoTx Facility for this. Just write <code>(:IWindsorContainer).AddFacility&lt;AutoTxFacility&gt;();</code>
            	when you are registering your components.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionAttribute.Equals(Castle.Services.Transaction.TransactionAttribute)">
            <summary>
            	Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            	true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name = "other">An object to compare with this object.</param>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionAttribute.Equals(System.Object)">
            <summary>
            	Determines whether the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />.
            </summary>
            <returns>
            	true if the specified <see cref = "T:System.Object" /> is equal to the current <see cref = "T:System.Object" />; otherwise, false.
            </returns>
            <param name = "obj">The <see cref = "T:System.Object" /> to compare with the current <see cref = "T:System.Object" />. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionAttribute.GetHashCode">
            <summary>
            	Serves as a hash function for a particular type.
            </summary>
            <returns>
            	A hash code for the current <see cref = "T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Castle.Services.Transaction.TransactionAttribute.Timeout">
            <summary>
            	Gets or sets the transaction timeout. The timeout is often better
            	implemented in the database, so this value is by default <see cref="F:System.TimeSpan.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.TransactionAttribute.Fork">
            <summary>
            	Gets or sets whether the current transaction should be forked off as a unit of work to the thread pool.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.TransactionAttribute.AsyncCommit">
            <summary>
            	Gets or sets whether the commit should be done asynchronously. Default is false. If you have done a lot of work
            	in the transaction, an asynchronous commit might be preferrable.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.TransactionAttribute.AsyncRollback">
            <summary>
            	Whether to perform the rollback asynchronously. This means that a failed transaction cleans up asynchronously.
            </summary>
        </member>
        <member name="P:Castle.Services.Transaction.TransactionAttribute.CustomContext">
            <summary>
            	Hint: <see cref="T:System.Collections.Generic.Dictionary`2"/> implements the return type.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.TransactionManager.EnlistDependentTask(System.Threading.Tasks.Task)">
            <summary>
            	Enlists a dependent task in the current top transaction.
            </summary>
            <param name = "task">
            	The task to enlist; this task is the action of running
            	a dependent transaction on the thread pool.
            </param>
        </member>
        <member name="P:Castle.Services.Transaction.TransactionManager.Logger">
            <summary>
            Gets or sets the logger - this is set through inversion
            of control.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Internal.TxScope">
            <summary>
            	A TxScope sets the ambient transaction for the duration of its lifetime and then re-assigns the previous value.
            	This class is NOT for public consumption. Use it if you are dealing
            	with <see cref="T:System.Transactions.CommittableTransaction"/> and <see cref="T:System.Transactions.DependentTransaction"/>
            	manually (and not using the transaction services to do it); otherwise
            	the <see cref="T:Castle.Services.Transaction.ITransactionManager"/> will take care of setting the 
            	correct static properties for you.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Internal.TxScope.#ctor(System.Transactions.Transaction,Castle.Core.Logging.ILogger)">
            <summary>
            	A TxScope sets the ambient transaction for the duration of its lifetime and then re-assigns the previous value.
            	This class is NOT for public consumption. Use it if you are dealing
            	with <see cref="T:System.Transactions.CommittableTransaction"/> and <see cref="T:System.Transactions.DependentTransaction"/>
            	manually (and not using the transaction services to do it); otherwise
            	the <see cref="T:Castle.Services.Transaction.ITransactionManager"/> will take care of setting the 
            	correct static properties for you.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.TransactionState">
            <summary>
            An enum of the possible states a transaction might take. Due to
            the concurrent nature of a transaction that is talking to a resource manager
            hosted in another thread and the nature of distributed software, the transaction
            state is only a best guess (there is no truth), based on what methods have been
            called on the Transaction. If, for example, a <see cref="T:System.Transactions.DependentTransaction"/>
            has Rollback() called on it, the parent transaction has no way of getting
            deterministically notified, so its state will still be active, until
            Commit() is called on it (or <see cref="T:Castle.Services.Transaction.ITransaction"/>.Complete() in the case of the API);
            then <see cref="T:System.Transactions.TransactionAbortedException"/> will be thrown.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionState.Default">
            <summary>
            	Initial state before c'tor run
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionState.Active">
            <summary>
            	When begin has been called and has returned.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionState.InDoubt">
            <summary>
            	When the transaction is in doubt. This occurs if e.g. the durable resource
            	fails after Prepare but before the ACK for Commit has reached the application on
            	which this transaction framework is running.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionState.CommittedOrCompleted">
            <summary>
            	When commit has been called and has returned successfully.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionState.Aborted">
            <summary>
            	When first begin and then rollback has been called, or
            	a resource failed.
            </summary>
        </member>
        <member name="F:Castle.Services.Transaction.TransactionState.Disposed">
            <summary>
            	When the dispose method has run.
            </summary>
        </member>
        <member name="T:Castle.Services.Transaction.Utils.Fun">
            <summary>
            	A functional-programming class which can help in memoizing function calls,
            	i.e. cache them.
            </summary>
        </member>
        <member name="M:Castle.Services.Transaction.Utils.Fun.Memoize``1(System.Func{``0})">
            <summary>
            	Memoize this function, indefinately.
            </summary>
            <typeparam name = "TRes">Result type</typeparam>
            <param name = "f">Function to memoize</param>
            <returns>A memoized function</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Utils.Fun.Memoize``2(System.Func{``0,``1})">
            <summary>
            	See <see cref="M:Castle.Services.Transaction.Utils.Fun.Memoize``2(System.Func{``0,``1},System.TimeSpan,System.Func{``1,System.Boolean})"/>
            </summary>
            <typeparam name="TA"></typeparam>
            <typeparam name="TRes"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Services.Transaction.Utils.Fun.Memoize``2(System.Func{``0,``1},System.TimeSpan,System.Func{``1,System.Boolean})">
            <summary>
            	Memoize this function.
            </summary>
            <typeparam name = "TA">First function argument</typeparam>
            <typeparam name = "TRes">Type of result</typeparam>
            <param name = "f">Function to memoize</param>
            <param name = "pDur">Duration during which to save the value.</param>
            <param name = "keepIt">Whether to save/memoize the function or not</param>
            <returns>A memoized function.</returns>
        </member>
        <member name="M:Castle.Services.Transaction.Utils.Fun.Memoize``1(System.Func{``0},System.TimeSpan)">
            <summary>
            	Memoize this function, a given timespan.
            </summary>
            <typeparam name = "TRes">Result type</typeparam>
            <param name = "f">Function to memoize</param>
            <param name = "pDur">Timespan during which to keep the results.</param>
            <returns>A memoized function</returns>
        </member>
    </members>
</doc>
